/*
 * linker: The linker source files compile into a single application which
 *		combines several assembly files generated by the assembler, library
 *		files created by the linker and a bootstrap file. The assemblies
 *		are written to a single executable file which can be executed on
 *		processing units.
 *
 *		The linker does all the label location resolving. The following steps
 *		explain how the linker works:
 *
 *		1) create a list to hold all assemblies
 *		2) load the bootstrap file and add it first to the list
 *		3) load all assembly source files and add them to the list
 *		4) 'connect' all labels which are marked imported with
 *					labels having the same name and are marked exported,
 *					if required, add library assemblies to the list
 *					(resolve_labels)
 *		5) calculate the total size of the combined size of the four
 *					segments of all assemblies (and thus the offsets of
 *					all segments in the final executable file 
 *					(recomp_addresses)
 *		6) calculate the addresses of all labels. Each label contains
 *					a pointer the the segment it exists in, and the relative
 *					position in this segment, or it contains a pointer to a
 *					'master' label (when the label is imported). In both 
 *					cases the label address can be computed 
 *					(recomp_addresses)
 *		7) update segment data, using the label bitmaps the binary
 *					segments are updated with the label locations.
 *					(update_segment)
 *		8) write all segments to the output file
 *
 *		Additionally, the linker is also used to combine several assemblies
 *		in a library file. The library file is nothing more than a archive
 *		with exact copies of multiple assembly files. See library.h for more
 *		information about the libraries.
 *
 *		Note that the BSS segment is not included in the executable file.
 *		this segment does not contain any valid data (only uninitialized
 *		variables) and is not included in the executable file. The bootstrap
 *		code should allocate the right amount of space for the BSS segment.
 *		To make this possible, the linker installs a dummy label called
 *		'$endprog' placed at the end of the bss segment (outside the 
 *		executable file). Using the 'address' directive, the total amount of
 *		space required by the program can be found.
 *
 *	Author: Sijmen Woutersen
 */

#ifndef LINKER_H
#define LINKER_H
#include "bool.h"
#include <stdio.h>
#include "memstream.h"
#include "instructions.h"
#include "hashtable.h"
#include "list.h"

/* amount of bytes read from a file per fread() call */
#define BUFFERSIZE 1024				

/* debug file extension (incl dot) */
#define DEBUG_EXT			".dbg"

/* label debug types */
#define LABEL_DEBUG_NONE 0			/* normal label */
#define LABEL_DEBUG_LINE 1			/* line number */
#define LABEL_DEBUG_FILE 2			/* filename */
#define LABEL_DEBUG_FUNCTION 3	/* function description */
#define LABEL_DEBUG_GLOBAL 4		/* global variable description */
#define LABEL_DEBUG_LOCAL 5			/* local variable description */
#define LABEL_DEBUG_PARAM 6			/* parameter description */
#define LABEL_DEBUG_FIELD 7			/* field description */
#define LABEL_DEBUG_TYPEDEF 8		/* typedef description */

/* label info structure */
typedef struct label {
	char* name;									/* name of the label */
	int segment;								/* segment of label location */
	int location;								/* location of label */
	struct assembly* assembly;	/* assembly in which the label exists */
	int id;											/* label id (unique within assembly */
	struct label* dep;					/* dependency label (if nonzero, the location, segment
																	and assembly should be taken from this label instead
																	of the current label (note: the dep label might also
																	have a dep label */
	int offset;									/* offset, should be added to the dep's label location */
	BOOL exported;							/* if the label is exported or not (can be called from 
																	other assemblies) */
	BOOL imported;							/* if the label is imported or not (actual location lies
																	in an other assembly */
	int debuginfo;							/* label contains debuf information */
} Label;

/* segment info structure */
typedef struct segment {
	int offset;									/* segment position in executable file */
	int segment;								/* segment type (see instructions.h) */
	Memstream* data;						/* segment data */
	Memstream* mask;						/* segment label bitmap */
} Segment;

/* assembly info structure */
typedef struct assembly {
	Segment* code;							/* code segment */
	Segment* lit;								/* lit segment */
	Segment* data;							/* data segment */
	int bss_size;								/* bss segment size */
	int bss_offset;							/* bss segment location */
	HashTable* labels;					/* labels */
	int label_count;						/* number of labels in table */
	char* source;								/* some information about the source of the assembly, used 
																	for debugging */
} Assembly;

/* load an assembly from a file, register all public functions and variables in hashtable */
Assembly* load_assembly(FILE*, HashTable*, char*);
/* write an error message to screen and exit the application */
void error(char*);
/* print all labels to stdout (debug) */
void printLabels(HashTable*);
/* print all public functions and variables to stdout */
void printPublics(HashTable*, int);
/* find a label in a specific hashtable (errors when not found) */
Label* find_label(HashTable*, char*);
/* find a label in an assembly by an id */
Label* find_label_by_id(Assembly*, int);
/* update a segment: fill the label locations */
void update_segment(Assembly*, Segment*);
/* resolve all labels; find all imported labels, include libraries etc */
/* returns FALSE if nonresolved labels */
BOOL resolve_labels(List*, HashTable*, HashTable*);
/* recompute all label addresses */
void recomp_addresses(List*, int);
/* recompute one label address */
void update_label_location(Label*);
/* print linker usage to screen */
void printUsage();
/* create a new label */
Label* create_label(char*);
/* create a new assembly containing only one label (and no data) */
Assembly* create_single_label_assembly(Label*);
/* convert hexadecimal string to integer */
int hex2bin(char*);
/* copies the first filename into the second, replacing the extenstion with
		3rd parameter */
void replace_ext(char*, char*, char*);

#endif
