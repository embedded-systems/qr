-- This file is automatically generated from __FILE__ and CONFIGURATION_FILE at __TIME__ __DATE__.

-------------------------------------------------------------------------------
-- Filename:             toplevel.vhd/toplevel._vhd
-- Entity:               x32
-- Architectures:        behaviour
-- Author:               Sijmen Woutersen, modified by Matias Escudero for TE300
--                       board and for the new memory cache module.
-- Last Modified:        2010/04/16
-- Version:              1.1
-- Description:          X32 toplevel component. Connects the X32 core to the
--                       memory and peripheral mux. The bootloader
--                       code was removed for this version. Now the clock signal 
--                       (50MHz) is generated inside the SDRAM interface. When
--                       the clock signal is stable, the reset waits for 200us
--                       and goes to zero. Is not posible to reset the hardware
--                       again. The monitor program is stored in the cache when
--                       the bit file is loaded in the FPGA.
--                       Note: this file may either be in a
--                       preprocessed (.vhd) or unpreprocessed (._vhd) state,
--                       use filepp (see makefile) to preprocess the file into
--                       a valid vhdl file using an X32 configuration file.
--
-- 	Copyright (c) 2005-2007, Software Technology Department, TU Delft
--	All rights reserved.
--
-- 	This program is free software; you can redistribute it and/or
--	modify it under the terms of the GNU General Public License
--	as published by the Free Software Foundation; either version 2
--	of the License, or (at your option) any later version.
--	
--	This program is distributed in the hope that it will be useful,
-- 	but WITHOUT ANY WARRANTY; without even the implied warranty of
--	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
--	GNU General Public License for more details.
--	
--	You should have received a copy of the GNU General Public License
--	along with this program; if not, write to the Free Software
-- 	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  
--  02111-1307, USA.
--	
--  See the GNU General Public License here:
--
--  http://www.gnu.org/copyleft/gpl.html#SEC1
-------------------------------------------------------------------------------

#include CONFIGURATION_FILE

library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;
use work.types.all;
use work.cache_parameters.all;

entity x32 is
	port (
		#define __IN_SIGLIST
		#include CONFIGURATION_FILE
		#undef __IN_SIGLIST

		board_led                     : out   std_logic;
		-- SDRAM Signals
		cntrl0_ddr_dq                 : inout std_logic_vector(15 downto 0);
		cntrl0_ddr_a                  : out   std_logic_vector(12 downto 0);
		cntrl0_ddr_ba                 : out   std_logic_vector(1 downto 0);
		cntrl0_ddr_cke                : out   std_logic;
		cntrl0_ddr_cs_n               : out   std_logic;
		cntrl0_ddr_ras_n              : out   std_logic;
		cntrl0_ddr_cas_n              : out   std_logic;
		cntrl0_ddr_we_n               : out   std_logic;
		cntrl0_ddr_dm                 : out   std_logic_vector(1 downto 0);
		cntrl0_rst_dqs_div_in         : in    std_logic;
		cntrl0_rst_dqs_div_out        : out   std_logic;
		sys_clk_in                    : in    std_logic;
	    --cntrl0_led_error_output1      : out   std_logic;
		cntrl0_data_valid_out         : out   std_logic;
		cntrl0_init_done              : out   std_logic;
		cntrl0_ddr_dqs                : inout std_logic_vector(1 downto 0);
		cntrl0_ddr_ck                 : out   std_logic_vector(0 downto 0);
		cntrl0_ddr_ck_n               : out   std_logic_vector(0 downto 0)


		
	);
end entity;

architecture behaviour of x32 is
	
	signal clk			: std_logic;

	-- proc signals
	signal proc_reset		: std_logic;
	signal proc_data_out		: std_logic_vector(CORE_SIZE_LONG-1 downto 0);
	signal proc_data_in		: std_logic_vector(CORE_SIZE_LONG-1 downto 0);
	signal proc_data_address	: std_logic_vector(CORE_SIZE_POINTER-1 downto 0);
	signal proc_data_size		: std_logic_vector(2 downto 0);
	signal proc_data_signed		: std_logic;
	signal proc_data_read		: std_logic;
	signal proc_data_write		: std_logic;
	signal proc_data_ready		: std_logic;
	
	-- memory signals
	signal mem_data_out		: std_logic_vector(CORE_SIZE_LONG-1 downto 0);
	signal mem_data_in		: std_logic_vector(CORE_SIZE_LONG-1 downto 0);
	signal mem_data_address		: std_logic_vector(CORE_SIZE_POINTER-1 downto 0);
	signal mem_data_size		: std_logic_vector(2 downto 0);
	signal mem_data_signed		: std_logic;
	signal mem_data_read		: std_logic;
	signal mem_data_write		: std_logic;
	signal mem_data_ready		: std_logic;
	
	-- processor state signals
	signal out_of_memory		: std_logic;
	signal trapped			: std_logic;
	signal procstate		: std_logic_vector(7 downto 0);
	signal proc_overflow		: std_logic;
	signal mem_overflow		: std_logic;
	signal division_by_zero		: std_logic;
	
	#ifdef INTERRUPTS_ENABLE
		-- interrupt signals
		signal irqs			: std_logic_vector(16-1 downto 0);
		signal ie			: std_logic_vector(16 downto 0);
	
		signal interrupt_ack		: std_logic;
		signal execution_level		: std_logic_vector(CORE_SIZE_LONG-1 downto 0);
		
		signal ic_data_out		: std_logic_vector(CORE_SIZE_LONG-1 downto 0);
		signal ic_data_ready		: std_logic;
		signal ic_data_read		: std_logic;
		signal ic_data_write		: std_logic;
	#endif
	-- more interrupt signals, these must be defined to connect to the core
	signal interrupt		: std_logic;
	signal interrupt_address	: std_logic_vector(CORE_SIZE_POINTER-1 downto 0);
	signal interrupt_level		: std_logic_vector(CORE_SIZE_LONG-1 downto 0);
	
	-- peripheral bus signals
	signal periph_data_out		: std_logic_vector(CORE_SIZE_LONG-1 downto 0);
	signal periph_data_read		: std_logic;
	signal periph_data_write	: std_logic;
	signal periph_data_ready	: std_logic;
	signal instruction_counter	: std_logic_vector(CORE_SIZE_LONG-1 downto 0);
	
	-- in execute state
	signal execute			: std_logic;

	-- application size
	signal app_size			: std_logic_vector(CORE_SIZE_POINTER-1 downto 0);	
	-- application stack starts here
	signal stack_start 		: std_logic_vector(31 downto 0);
	-- application starts executing from here
	signal app_base 		: std_logic_vector(CORE_SIZE_POINTER-1 downto 0);
	constant app_base_c		: std_logic_vector(CORE_SIZE_POINTER-1 downto 0) := conv_std_logic_vector(unhex(ROM_LOCATION), CORE_SIZE_POINTER);

	-- System reset
	signal reset_out		: std_logic;

	-- X32 reset
	signal reset			: std_logic;

	signal cache_miss_counter	: std_logic_vector(31 downto 0);

begin

	reset <= reset_out;

	app_base <= conv_std_logic_vector(unhex(ROM_LOCATION), CORE_SIZE_POINTER);
	app_size <= conv_std_logic_vector(unhex(ROM_SIZE), CORE_SIZE_POINTER);
	
	-- processor state
	--		7		trapped
	--		6		out of memory
	--		5		<unused>
	--		4		overflow
	--		3		division_by_zero
	--		2		<unused>
	--		1		simulator
	--		0		booting
	procstate(7) <= trapped;
	procstate(6) <= out_of_memory;
	procstate(5) <= '0';
	procstate(4) <= proc_overflow or mem_overflow;
	procstate(3) <= division_by_zero;
	procstate(2) <= '0';
	procstate(1) <= '0';
	procstate(0) <= '0';

	#ifdef OOM_LOWER_BOUND
		#ifdef OOM_UPPER_BOUND
			out_of_memory <= proc_data_read or proc_data_write when
				proc_data_address > conv_std_logic_vector(unhex(OOM_LOWER_BOUND), unhex(CORE_SIZE_LONG))
				and proc_data_address < conv_std_logic_vector(unhex(OOM_UPPER_BOUND), unhex(CORE_SIZE_LONG))
				else '0';
		#else
			#ifdef OOM_IRQ
				#warning "OOM_IRQ is defined, but OOM_UPPER_BOUND is not!"
			#endif
			out_of_memory <= '0';
		#endif
	#else
		#ifdef OOM_IRQ
			#warning "OOM_IRQ is defined, but OOM_LOWER_BOUND is not!"
		#endif
		out_of_memory <= '0';
	#endif

	
	stack_start <= app_base_c(CORE_SIZE_POINTER-1 downto ROM_ADDRESS_BITS) & app_size(ROM_ADDRESS_BITS-1 downto 0);
	l_processor: entity work.x32_core(behaviour)
		generic map (
			size_short 	=> CORE_SIZE_SHORT, 
			size_integer 	=> CORE_SIZE_INT, 
			size_long 	=> CORE_SIZE_LONG, 
			size_pointer 	=> CORE_SIZE_POINTER,
			#ifdef DEBUG_NOBUFFER
				use_buffer => false
			#else
				use_buffer => true
			#endif
		)
		port map (
			clk => clk, 
			reset => proc_reset, 
			mem_addr => proc_data_address, 
			mem_data_in => proc_data_in, 
			mem_data_out =>	proc_data_out, 
			mem_read => proc_data_read, 
			mem_write => proc_data_write, 
			mem_data_signed => proc_data_signed, 
			mem_data_size => proc_data_size, 
			mem_ready => proc_data_ready, 

			#ifdef INTERRUPTS_ENABLE
				interrupt => interrupt, 
				interrupt_ack => interrupt_ack, 
				interrupt_address => interrupt_address,
				interrupt_level => interrupt_level, 
				execution_level => execution_level,
			#else
				interrupt => interrupt, 
				interrupt_address => interrupt_address,
				interrupt_level => interrupt_level, 
			#endif

			app_start => app_base, 
			stack_start => stack_start, 
			instruction_counter => instruction_counter,  
			execute => execute,
			overflow => proc_overflow,
			division_by_zero => division_by_zero,
			trapped => trapped
		);

	-- blink each 2097152 instructions (between on and on).
	board_led <= instruction_counter(20);

	-- Memory - Cache + Controllers + SDRAM interface
	l_memory: entity work.ddr_sdram(Behavioral)
		generic map (
			address_tag_init => app_base_c( PHY_MEM_ADDR_BITS - 1 downto PHY_MEM_ADDR_BITS - CACHE_TAG_BITS)
		)
		port map(

			-- Clocking / Resets
			clk_o		=> open,
			clk90_o		=> open,
			clk_50MHz_o	=> clk,
			reset_o	        => reset_out,
			reset90_o	=> open,
			
			-- To SDRAM Interface

			cntrl0_ddr_dq            => cntrl0_ddr_dq,
			cntrl0_ddr_a             => cntrl0_ddr_a,
			cntrl0_ddr_ba            => cntrl0_ddr_ba,
			cntrl0_ddr_cke           => cntrl0_ddr_cke,
			cntrl0_ddr_cs_n          => cntrl0_ddr_cs_n,
			cntrl0_ddr_ras_n         => cntrl0_ddr_ras_n,
			cntrl0_ddr_cas_n         => cntrl0_ddr_cas_n,
			cntrl0_ddr_we_n          => cntrl0_ddr_we_n,
			cntrl0_ddr_dm            => cntrl0_ddr_dm,
			cntrl0_rst_dqs_div_in    => cntrl0_rst_dqs_div_in,
			cntrl0_rst_dqs_div_out   => cntrl0_rst_dqs_div_out,
			cntrl0_led_error_output1 => open,
			sys_clk_in               => sys_clk_in,
			reset_in_n               => '0',
        
			cntrl0_init_done         => cntrl0_init_done,
			cntrl0_ddr_dqs           => cntrl0_ddr_dqs,
			cntrl0_ddr_ck            => cntrl0_ddr_ck,
			cntrl0_ddr_ck_n          => cntrl0_ddr_ck_n,
			
			-- X32 memory bus
			mem_address 	=> mem_data_address(25 downto 0),
			mem_data_in 	=> mem_data_in, 
			mem_data_out 	=> mem_data_out, 
			mem_read 	=> mem_data_read, 
			mem_write 	=> mem_data_write, 
			mem_ready 	=> mem_data_ready, 
			mem_data_size 	=> mem_data_size,
			mem_data_signed => mem_data_signed,
			overflow 	=> mem_overflow,
			cache_miss_counter 	=> cache_miss_counter

		);



	-- Peripherals
	l_peripherals: entity work.peripherals(behaviour)
		port map (
			clk => clk,
			address => proc_data_address(30 downto 0),
			data_in	=> proc_data_out,
			data_out => periph_data_out,
			read => periph_data_read,
			write => periph_data_write,
			ready => periph_data_ready,

			#ifdef INTERRUPTS_ENABLE
				irqs => irqs,
				ie => ie,
			#endif

			#define __IN_SIGMAPLIST
			#include CONFIGURATION_FILE
			#undef __IN_SIGMAPLIST

			procstate => procstate,
			instruction_counter => instruction_counter,
			cache_miss_counter => cache_miss_counter,
			reset => reset_out
		);



	-- Interrupt Controller
	#ifdef INTERRUPTS_ENABLE
		l_ic: entity work.interrupt_controller(behaviour)
			generic map (
				devices => INTERRUPT_COUNT,
				size => CORE_SIZE_LONG,
				address_bits => log2_ceil(INTERRUPT_COUNT-1)+1,
				#ifdef INTERRUPT_CRITICAL
					critical_interrupt => unhex(INTERRUPT_CRITICAL)
				#else
					-- number higher than all irq indices => no critical interrupt
					critical_interrupt => 0
				#endif
			)
			port map (
				clk => clk,
				reset => reset,
				irqs => irqs,
				ie => ie,
				interrupt => interrupt,
				interrupt_ack => interrupt_ack,
				current_priority => execution_level,
				priority => interrupt_level,
				handler_address => interrupt_address,
				ram_in => proc_data_out,
				ram_out => ic_data_out,
				ram_address => proc_data_address(log2_ceil(INTERRUPT_COUNT-1)+2 downto 2),
				ram_write => ic_data_write,
				ram_read => ic_data_read,
				ram_ready => ic_data_ready
			);
	#else
		-- very, very simple interrupt controller
		interrupt <= '0';
		interrupt_address <= (others => '0');
		interrupt_level <= (others => '0');
	#endif



	-- X32 Memory bus multiplexor 
	process(proc_data_address, proc_data_read, proc_data_write,
		mem_data_ready, periph_data_ready, mem_data_out, periph_data_out, 
		#ifdef INTERRUPTS_ENABLE
			ic_data_out, ic_data_ready,
		#endif
		proc_data_out, proc_data_size, proc_data_signed) begin
		
		mem_data_address <= proc_data_address;
		mem_data_in <= proc_data_out;
		mem_data_size <= proc_data_size;
		mem_data_signed <= proc_data_signed;

		if (proc_data_address(31) = '0') then
			-- map to memory:
			proc_data_in <= mem_data_out;
			
			mem_data_read <= proc_data_read;
			mem_data_write <= proc_data_write;
			proc_data_ready <= mem_data_ready;

			periph_data_read <= '0';
			periph_data_write <= '0';

			#ifdef INTERRUPTS_ENABLE
				ic_data_read <= '0';
				ic_data_write <= '0';
			#endif
		else
			#ifdef INTERRUPTS_ENABLE
				if (proc_data_address(30) = '0') then
			#endif
				-- peripherals
				proc_data_in <= periph_data_out;
				proc_data_ready <= periph_data_ready;
				periph_data_read <= proc_data_read;
				periph_data_write <= proc_data_write;
				mem_data_read <= '0';
				mem_data_write <= '0';

			#ifdef INTERRUPTS_ENABLE
				ic_data_read <= '0';
				ic_data_write <= '0';
			else
				-- interrupt controller
				proc_data_in <= ic_data_out;
				proc_data_ready <= ic_data_ready;
				ic_data_read <= proc_data_read;
				ic_data_write <= proc_data_write;
				periph_data_read <= '0';
				periph_data_write <= '0';
				mem_data_read <= '0';
				mem_data_write <= '0';
			end if;
			#endif
		end if;
	end process;

end architecture;
