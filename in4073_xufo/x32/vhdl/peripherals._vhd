-- This file is automatically generated from __FILE__ and CONFIGURATION_FILE at __TIME__ __DATE__.

-------------------------------------------------------------------------------
-- Filename:             peripherals.vhd/peripherals._vhd
-- Entity:               peripherals
-- Architectures:        behaviour
-- Author:               Sijmen Woutersen, modified by Matias Escudero for TE300
--                       board and for the new memory cache module.
-- Last Modified:        2010/04/16
-- Version:              1.1
-- Description:          Component which connects all peripheral devices to the
--                       X32 memory bus (note, this file may either be in a
--                       preprocessed (.vhd) or unpreprocessed (._vhd) state,
--                       use filepp (see makefile) to preprocess the file into
--                       a valid vhdl file using an X32 configuration file.
--                       
--
-- 	Copyright (c) 2005-2007, Software Technology Department, TU Delft
--	All rights reserved.
--
-- 	This program is free software; you can redistribute it and/or
--	modify it under the terms of the GNU General Public License
--	as published by the Free Software Foundation; either version 2
--	of the License, or (at your option) any later version.
--	
--	This program is distributed in the hope that it will be useful,
-- 	but WITHOUT ANY WARRANTY; without even the implied warranty of
--	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
--	GNU General Public License for more details.
--	
--	You should have received a copy of the GNU General Public License
--	along with this program; if not, write to the Free Software
-- 	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  
--  02111-1307, USA.
--	
--  See the GNU General Public License here:
--
--  http://www.gnu.org/copyleft/gpl.html#SEC1
-------------------------------------------------------------------------------


#include CONFIGURATION_FILE

library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;
use work.types.all;

entity peripherals is
	port (
		-- system clock (50MHz)
		clk	: in  std_logic;
		
		-- memory (peripheral) address
		address		: in  std_logic_vector(30 downto 0);
		-- data from processor
		data_in		: in  std_logic_vector(31 downto 0);
		-- data to processor
		data_out	: out std_logic_vector(31 downto 0);
		-- read command (active high)
		read		: in  std_logic;
		-- write command (active high)
		write		: in  std_logic;
		-- ready signal, alle read/write commands should
		--   be responded with a ready pulse to '1'
		ready		: out std_logic;

		#ifdef INTERRUPTS_ENABLE
			irqs		: out std_logic_vector(INTERRUPT_COUNT-1 downto 0);
			ie		: out std_logic_vector(INTERRUPT_COUNT downto 0);
		#endif

		#define __IN_SIGLIST
		#include CONFIGURATION_FILE
		#undef __IN_SIGLIST

		-- processor state
		-- note that there is no reason to connect these values to a peripheral address,
		--		since all flags will always be 0: when the processor halts, runs out of
		--		memory, or is booting, it is not executing software, and no software 
		--		program will thus ever detect a non-zero value on the procstate. It might
		--		however be used for interrupting the processor, if error recovery 
		--		code is available.
		--
		--		7		trapped
		--		6		out of memory
		--		5		<unused>
		--		4		overflow
		--		3		division_by_zero
		--		2		<unused>
		--		1		simulater (should be one only on interpreter)
		--		0		booting
		procstate		: in  std_logic_vector(7 downto 0);
		instruction_counter 	: in  std_logic_vector(31 downto 0);
		cache_miss_counter 	: in  std_logic_vector(31 downto 0);
		reset 			: in std_logic
	);
end entity;

architecture behaviour of peripherals is
	#ifdef INTERRUPTS_ENABLE
		signal ie_buff : std_logic_vector(INTERRUPT_COUNT downto 0);
		signal ie_buff_store : std_logic;
	#endif

	#define __IN_DECL
	#include CONFIGURATION_FILE
	#undef __IN_DECL

	#ifdef PROCSTATE_REGISTER_INDEX
		signal procstate_buff : std_logic_vector(7 downto 0);
		signal procstate_read : std_logic;
	#endif

	signal block_reset : std_logic := '0';

begin

	#ifdef PROCSTATE_REGISTER_INDEX
		procstate_read <= '1' when 
			address(unhex(PERIPHERAL_ADDRESS_BITS)+1 downto 2) =
			conv_std_logic_vector(unhex(PROCSTATE_REGISTER_INDEX), \
			unhex(PERIPHERAL_ADDRESS_BITS)) and read = '1' else '0';
	#endif

	-- the peripheral => processor data mux
	process(address) begin
		
		-- only look at address PERIPHERAL_ADDRESS_BITS+1 downto 2:
		--		the peripherals bus is not byte addressable 
		--		(which should not be a problem), and only 256
		--		devices can be connected (which should be enough)
		--
		--		device at x"00" maps to 0x80000000 (peripherals[0] in x32.h)
		--		device at x"01" maps to 0x80000004 (peripherals[1] in x32.h)
		--		device at x"02" maps to 0x80000008 (peripherals[2] in x32.h)
		--		etc
		case address(unhex(PERIPHERAL_ADDRESS_BITS)+1 downto 2) is
			-- peripheral id (keep this unique!)
			when pp_to_std_logic_vector(0,PERIPHERAL_ADDRESS_BITS) => -- 0x00 (Peripheral bus id)
				ready <= '1';
				data_out(31 downto 0) <= conv_std_logic_vector(unhex(PERIPHERAL_ID), \
					unhex(PERIPHERAL_DATA_BITS));

			#ifdef INSTRUCTION_COUNTER_INDEX
				when pp_to_std_logic_vector(INSTRUCTION_COUNTER_INDEX,PERIPHERAL_ADDRESS_BITS) => -- INSTRUCTION_COUNTER_INDEX (Instruction Counter)

					ready <= '1';
					data_out(31 downto 0) <= instruction_counter;
			#endif

			#ifdef 	CACHEMISS_COUNTER_INDEX
				when pp_to_std_logic_vector(CACHEMISS_COUNTER_INDEX,PERIPHERAL_ADDRESS_BITS) => -- CACHEMISS_COUNTER_INDEX (Cache miss Counter)

					ready <= '1';
					data_out(31 downto 0) <= cache_miss_counter;
			#endif

			#ifdef PROCSTATE_REGISTER_INDEX
				when pp_to_std_logic_vector(PROCSTATE_REGISTER_INDEX,PERIPHERAL_ADDRESS_BITS) => -- PROCSTATE_REGISTER_INDEX (Processor State Register)
					ready <= '1';
					data_out(31 downto 8) <= (others => '0');
					data_out(7 downto 0) <= procstate_buff;
			#endif

			#ifdef INTERRUPTS_ENABLE
				#ifdef INTERRUPT_ENABLE_INDEX
					when pp_to_std_logic_vector(INTERRUPT_ENABLE_INDEX,PERIPHERAL_ADDRESS_BITS) => -- INTERRUPT_ENABLE_INDEX (Interrupt Enable Register)
						ready <= '1';
						assert PERIPHERAL_DATA_BITS < INTERRUPT_COUNT+1
							report "Too many interrupts"
							severity error;

						data_out(31 downto INTERRUPT_COUNT+1) <= (others => '0');
						data_out(INTERRUPT_COUNT downto 0) <= ie_buff;
				#else
					#warning The interrupt enable register location is not defined, interrupts can't be enabled.
				#endif
			#endif
				
			#define __IN_MUX
			#include CONFIGURATION_FILE
			#undef __IN_MUX
			when others =>
				ready <= '1';
				data_out <= (others => '-');
		end case;
	end process;

	-- component vhdl code:
	#define __IN_VHDL
	#include CONFIGURATION_FILE
	#undef __IN_VHDL

	#ifdef INTERRUPTS_ENABLE
		#ifdef TRAP_IRQ
			#if unhex(INTERRUPT_COUNT) > unhex(TRAP_IRQ)
				irqs(unhex(TRAP_IRQ)) <= procstate(7);
			#endif
		#endif
		#ifdef OVERFLOW_IRQ
			#if unhex(INTERRUPT_COUNT) > unhex(OVERFLOW_IRQ)
				irqs(unhex(OVERFLOW_IRQ)) <= procstate(4);
			#endif
		#endif
		#ifdef DIV0_IRQ
			#if unhex(INTERRUPT_COUNT) > unhex(DIV0_IRQ)
				irqs(unhex(DIV0_IRQ)) <= procstate(3);
			#endif
		#endif
		#ifdef OOM_IRQ
			#if unhex(INTERRUPT_COUNT) > unhex(OOM_IRQ)
				irqs(unhex(OOM_IRQ)) <= procstate(6);
			#endif
		#endif
	#endif

	#ifdef PROCSTATE_REGISTER_INDEX
		process(clk, reset, procstate, procstate_read) begin
			if (clk'event and clk = '1') then
				if (reset = '1' or procstate_read = '1') then
					procstate_buff <= (others => '0');
				else
					for i in 0 to 7 loop
						if (procstate(i) = '1') then
							procstate_buff(i) <= '1';
						end if;
					end loop;
				end if;
			end if;
		end process;
	#endif


	#ifdef INTERRUPTS_ENABLE
		#ifdef INTERRUPT_ENABLE_INDEX
			-- interrupt enable register
			ie <= ie_buff;

			ie_buff_store <= '1' when write = '1' and \
				address(unhex(PERIPHERAL_ADDRESS_BITS)+1 downto 2) = \
				conv_std_logic_vector(unhex(INTERRUPT_ENABLE_INDEX), \
				unhex(PERIPHERAL_ADDRESS_BITS)) else '0';

			l_ie_buff: entity work.reg(behaviour)
				generic map (
					size => unhex(INTERRUPT_COUNT)+1
				)
				port map (
					clk => clk,
					reset => reset,
					store => ie_buff_store,
					data_in => data_in(unhex(INTERRUPT_COUNT) downto 0),
					data_out => ie_buff
				);

		#endif
	#endif
end architecture;
